package parser;

import scanner.LexicalUnit;
import scanner.Symbol;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Stack;
import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;

/**
 * This class is the main class, it represents the parser
 * It contains various methods sued to parse and generate a Parse tree
 */
public class Parser {
    private final Stack<String> stack = new Stack<>();
    private final ActionTable actionTable = new ActionTable();
    private final ArrayList<Symbol> symbols;
    private final Rules rules = new Rules();
    private ParseTree node;
    private StringBuilder builder;

    /**
     * The main constructor of the class
     * @param symbols the list of symbols generated by the {@link scanner.FlexManager}
     */
    public Parser(ArrayList<Symbol> symbols){
        this.symbols = symbols;
    }

    public ParseTree getParseTree(){
        return this.node;
    }

    /**
     * This method will return the {@link ParseTree} into a latex string
     * @return the tree in a latex string
     */
    public String latexTree(){
        return node.toLaTeX();
    }

    /**
     * This method creates a file and writes the latex tree in it
     * @param fileName the name of the file
     * @throws IOException If an I/O error occurred
     */
    public void creatLatexFile(String fileName) throws IOException {
        File file = new File(fileName);
        if (file.createNewFile()){
            FileWriter writer = new FileWriter(fileName);
            writer.write(latexTree());
            writer.close();
        }
    }

    /**
     * This method will generate a beautiful string containing the rules
     * @return the the beautiful string
     */
    public String prettyPrint(){
        StringBuilder printRules = new StringBuilder();
        String[] rulesString = builder.toString().split(" ");
        for(String rule : rulesString){
            printRules.append("(").append(rule).append(") ");
            int ruleNumber = Integer.parseInt(rule);
            printRules.append(rules.getRuleVariable(ruleNumber)).append(" -> ").append(rules.getRule(ruleNumber).toString());
            printRules.append("\n");

        }
        return printRules.toString();
    }


    /**
     * This is the main method of the class, it will iterate over all the symbols and do the appropriate action
     * @return the string of rule
     * @throws InvalidSyntaxException Whenever there is a syntax error in the input file
     */
    public String parse() throws InvalidSyntaxException {
        stack.push("$");
        stack.push("PROGRAM");
        node = new ParseTree(new Variable(LexicalVariable.PROGRAM));
        ParseTree currentNode = node;
        builder = new StringBuilder();
        int i = 0;
        while (i < symbols.size()) {
            String topStack = stack.peek(); // nullable
            LexicalUnit type = symbols.get(i).getType(); // nullable
            Object value = symbols.get(i).getValue();   // nullable
            String currentInput = transform(type.toString());
            Symbol symbol = symbols.get(i);
            if (topStack != null && topStack.equals(currentInput)) {
                currentNode = match(currentNode, currentInput, value);
                i++;
            } else {
                    currentNode = produce(currentNode, currentInput, symbol, value);
            }
        }
        while (!stack.peek().equals("$")){
            Integer ruleNumber = actionTable.getData(stack.peek(), "$");
            if (ruleNumber != null) {
                stack.pop();
                currentNode = addStack(currentNode,ruleNumber);
                builder.append(ruleNumber).append(" ");
            } else {
                throw new InvalidSyntaxException("Error: EndOfFile found but not expected");
            }
        }
        return builder.toString();
    }

    /**
     * This method will add children to the current tree
     * @param tree the current tree
     * @param toAdd the list of children we want to add to the current tree
     */
    private void addTree(ParseTree tree, List<String> toAdd){
        for (String stringVariable : toAdd) {
            if (LexicalVariable.contains(stringVariable)){
                tree.addChild(new ParseTree(new Variable(LexicalVariable.valueOf(stringVariable))));
            } else {
                tree.addChild(new ParseTree(new Variable(stringVariable)));

            }
        }
    }

    /**
     * This method is called whenever there is a match,
     * it will set the label of the current tree and return the next tree
     * @param tree the current tree
     * @param input the input string found
     * @param value the value of the symbol found
     * @return the next tree to analyze
     */
    private ParseTree match(ParseTree tree, String input, Object value){
        stack.pop();
        if (Arrays.asList("VARNAME", "PROGNAME", "NUMBER").contains(input)){
            tree.setLabel(new Variable(input + ": " + value.toString()));
        }
        return tree.getNext();
    }

    /**
     * This method will get the rule from the action table and will add the product of the rule
     * @param tree the current tree to analyze
     * @param input the input we found the file
     * @param symbol the input in symbol form
     * @param value the value of the symbol
     * @return the next tree to analyze
     * @throws InvalidSyntaxException if there is a syntax error in the file
     */
    private ParseTree produce(ParseTree tree, String input, Symbol symbol, Object value) throws InvalidSyntaxException {
        Integer ruleNumber = actionTable.getData(stack.peek(), input);
        if (ruleNumber != null) {
            stack.pop();
            tree = addStack(tree, ruleNumber);
            builder.append(ruleNumber).append(" ");
        } else{
            throw new InvalidSyntaxException("Error: Invalid Syntax", symbol.getLine(), stack.peek(), value.toString());
        }
        return tree;
    }

    /**
     * This method will add the product of the rule "ruleNumber" into the stack, in reversed order
     * @param tree the current node of the tree
     * @param ruleNumber the number of the rule we want to apply
     * @return the next tree to analyze
     */
    private ParseTree addStack(ParseTree tree, int ruleNumber){
        List<String> product = rules.getRule(ruleNumber);
        if (product.size()!= 0) {
            addTree(tree, product);
            stack.addAll(rules.getRuleReversed(ruleNumber));
            tree = tree.getFirstChild();
        } else {
            tree.addChild(new ParseTree(new Variable(" ")));
            tree = tree.getNext();
        }
        return tree;
    }


    /**
     * This method transforms a column into the correct string
     * @param columnName the name of the column we want to convert
     * @return the converted column string
     */
    private String transform(String columnName){
        switch (columnName) {
            case "LPAREN":
                columnName = "(";
                break;
            case "RPAREN":
                columnName = ")";
                break;
            case "ASSIGN":
                columnName = ":=";
                break;
            case "PLUS":
                columnName = "+";
                break;
            case "MINUS":
                columnName = "-";
                break;
            case "TIMES":
                columnName = "*";
                break;
            case "DIVIDE":
                columnName = "/";
                break;
            case "EQ":
                columnName = "=";
                break;
            case "GT":
                columnName = ">";
                break;
        }
        return columnName;
    }
}


